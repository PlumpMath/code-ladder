;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var test_code;

test_code = "https://github.com/qiao/coffee-box/blob/master/app/controllers/posts_controller.coffee\nexports.getPostsController = (app) ->\n  exceptions              = require '../../lib/exceptions'\n  RSS                     = require('rss')\n  {Post}                  = app.settings.models\n  {postPath}              = app.settings.helpers\n  {markdown, makeTagList} = app.settings.utils\n\n  return {\n\n    # GET /posts\n    index: (req, res, next) ->\n      # check pagination param: /posts/?page=2\n      pageNo = parseInt(req.query['page'], 10) or 1\n\n      POSTS_PER_PAGE = 5\n      Post.countPostPages POSTS_PER_PAGE, (err, totalPages) ->\n        Post.getPostsOfPage pageNo, POSTS_PER_PAGE, (err, posts) ->\n          return res.redirect '500' if err?\n          res.render 'posts/index'\n            posts:      posts\n            pageNo:     pageNo\n            totalPages: totalPages\n\n    # GET /year/month/day/:slug.:format?\n    show: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        res.render 'posts/show'\n          post: post\n\n    # GET /posts/new\n    new: (req, res, next) ->\n      res.render 'posts/new'\n        post: new Post\n\n    # GET /year/month/day/:slug/edit\n    edit: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        res.render 'posts/edit'\n          post: post\n\n    # POST /posts\n    create: (req, res, next) ->\n      post         = new Post\n      post.data    = req.body.post\n      post.save (err) ->\n        if err\n          req.flash 'error', exceptions.getMessage err\n          res.redirect 'back'\n        else\n          req.flash 'info', 'successfully posted'\n          res.redirect postPath(post)\n\n    # PUT /year/month/day/:slug\n    update: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        post.data = req.body.post\n        post.save (err) ->\n          if err\n            req.flash 'error', exceptions.getMessage err\n            res.redirect 'back'\n          else\n            req.flash 'info', 'successfully updated'\n            res.redirect postPath(post)\n\n    # DELETE /year/month/day/:slug\n    destroy: (req, res, next) ->\n      Post.removeBySlug req.params.slug, (err) ->\n        res.redirect 'back'\n\n    # find all posts published as individual pages\n    # this is a middleware to apply before all requests\n    findPages: (req, res, next) ->\n      Post.findPages (err, pages) ->\n        res.locals pages: pages\n        next()\n\n    # GET /:slug\n    showPage: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return next() unless post?\n        res.render 'posts/show'\n          post: post\n\n    # GET /feed\n    feed: (req, res, next) ->\n      Post.findPosts (err, posts) ->\n        feed = new RSS\n          title:       app.settings.sitename\n          description: app.settings.description\n          feed_url:    app.settings.url + '/feed'\n          author:      app.settings.author\n\n        for post in posts\n          feed.item\n            title:       post.title\n            description: post.content\n            url:         app.settings.url + postPath(post)\n            date:        post.createdAt\n\n        res.send feed.xml()\n\n    # POST /posts/preview\n    preview: (req, res, next) ->\n      markdown req.body.rawContent or '', (html) ->\n        res.send html, 200\n\n  }";

window.onload = function() {
  var dom, render;

  dom = require("./dom").rain;
  render = require("./render");
  dom.on("paste", function(value) {
    return dom.emit("render", render.convert(value));
  });
  return dom.emit("render", render.convert(test_code));
};

},{"./dom":2,"./render":3}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var detect, get_indent, make_html, make_list, make_tree;

detect = require("./detect");

get_indent = function(line) {
  var match;

  match = line.match(/^(\s*)/);
  return match[0].length;
};

make_list = function(code) {
  return code.split("\n").map(function(line) {
    return line.trimRight();
  }).filter(function(line) {
    return line.length > 0;
  });
};

make_tree = function(lines) {
  var last, tree;

  tree = {};
  last = void 0;
  lines.forEach(function(line) {
    var indent, n;

    n = get_indent(line);
    indent = void 0;
    if (n === 0) {
      if (Array.isArray(tree[last])) {
        tree[last] = make_tree(tree[last]);
      }
      last = line;
      tree[last] = [];
      return indent = void 0;
    } else {
      if (indent == null) {
        indent = n;
      }
      return tree[last].push(line.slice(2));
    }
  });
  if (Array.isArray(tree[last])) {
    tree[last] = make_tree(tree[last]);
  }
  return tree;
};

make_html = function(tree) {
  var add, html, key, value;

  html = "";
  add = function(string) {
    return html += string;
  };
  for (key in tree) {
    value = tree[key];
    add("<div class='unit'>");
    add("<div class='line'>");
    add(key);
    add("</div>");
    add("<div class='block'>");
    add(make_html(value));
    add("</div>");
    add("</div>");
  }
  return html;
};

exports.convert = function(code) {
  return make_html(make_tree(make_list(code)));
};

},{"./detect":4}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var use_space;

use_space = function(line) {
  return line.replace(/\t/g, "  ");
};

exports.indent = function(code) {
  var gather_indent, indent, lines;

  code = code.trim();
  indent = 80;
  gather_indent = function(line) {
    var after, before, diff;

    before = line.length;
    after = line.trimLeft().length;
    diff = before - after;
    if ((0 < diff && diff < indent)) {
      return indent = diff;
    }
  };
  lines = code.split("\n").map(String.prototype.trimRight.call).map(use_space).map(gather_indent);
  return indent;
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var EventEmitter, delay, elem, find, paper, rain;

find = function(query) {
  return document.querySelector(query);
};

EventEmitter = require("eventemitter").EventEmitter;

delay = function(t, f) {
  return setTimeout(f, t);
};

exports.rain = rain = new EventEmitter();

elem = find("#paste");

paper = find("#paper");

paper.onclick = function(event) {
  var next, style;

  elem = event.target;
  if (elem.className = "line") {
    next = elem.nextElementSibling;
    style = next.style;
    if (style.display === "none") {
      elem.style.background = "hsla(240,80%,90%,0)";
      return style.display = "block";
    } else if (next.childElementCount > 0) {
      elem.style.background = "hsl(240,80%,90%)";
      return style.display = "none";
    }
  }
};

elem.addEventListener("paste", function() {
  return delay(0, function() {
    return rain.emit("paste", elem.value);
  });
});

rain.on("render", function(html) {
  return paper.innerHTML = html;
});

},{"eventemitter":5}],5:[function(require,module,exports){
(function(){(function(exports) {
  var process = { EventEmitter: function() {} };
  
  if (typeof Array.isArray !== "function"){
    Array.isArray = function(obj){ return Object.prototype.toString.call(obj) === "[object Array]" };
  }
  
  if (!Array.prototype.indexOf){
    Array.prototype.indexOf = function(item){
        for ( var i = 0, length = this.length; i < length; i++ ) {
            if ( this[ i ] === item ) {
                return i;
            }
        }

        return -1;
    };
  }
  
  // Begin wrap of nodejs implementation of EventEmitter

  var EventEmitter = exports.EventEmitter = process.EventEmitter;

  var isArray = Array.isArray;

  EventEmitter.prototype.emit = function(type) {
    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events || !this._events.error ||
          (isArray(this._events.error) && !this._events.error.length))
      {
        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    if (!this._events) return false;
    var handler = this._events[type];
    if (!handler) return false;

    if (typeof handler == 'function') {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          var args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
      }
      return true;

    } else if (isArray(handler)) {
      var args = Array.prototype.slice.call(arguments, 1);

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
      return true;

    } else {
      return false;
    }
  };

  // EventEmitter is defined in src/node_events.cc
  // EventEmitter.prototype.emit() is also defined there.
  EventEmitter.prototype.addListener = function(type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('addListener only takes instances of Function');
    }

    if (!this._events) this._events = {};

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);
    } else {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function(type, listener) {
    var self = this;
    self.on(type, function g() {
      self.removeListener(type, g);
      listener.apply(this, arguments);
    });
  };

  EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('removeListener only takes instances of Function');
    }

    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
      var i = list.indexOf(listener);
      if (i < 0) return this;
      list.splice(i, 1);
      if (list.length == 0)
        delete this._events[type];
    } else if (this._events[type] === listener) {
      delete this._events[type];
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function(type) {
    // does not use listeners(), so no side effect of creating _events[type]
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  // End nodejs implementation
}((typeof exports === 'undefined') ? window : exports));
})()
},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvb3B0L3MvY29kZS1sYWRkZXIvbGliL21haW4uanMiLCIvb3B0L3MvY29kZS1sYWRkZXIvbGliL3JlbmRlci5qcyIsIi9vcHQvcy9jb2RlLWxhZGRlci9saWIvZGV0ZWN0LmpzIiwiL29wdC9zL2NvZGUtbGFkZGVyL2xpYi9kb20uanMiLCIvb3B0L3MvY29kZS1sYWRkZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbnZhciB0ZXN0X2NvZGU7XG5cbnRlc3RfY29kZSA9IFwiaHR0cHM6Ly9naXRodWIuY29tL3FpYW8vY29mZmVlLWJveC9ibG9iL21hc3Rlci9hcHAvY29udHJvbGxlcnMvcG9zdHNfY29udHJvbGxlci5jb2ZmZWVcXG5leHBvcnRzLmdldFBvc3RzQ29udHJvbGxlciA9IChhcHApIC0+XFxuICBleGNlcHRpb25zICAgICAgICAgICAgICA9IHJlcXVpcmUgJy4uLy4uL2xpYi9leGNlcHRpb25zJ1xcbiAgUlNTICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdyc3MnKVxcbiAge1Bvc3R9ICAgICAgICAgICAgICAgICAgPSBhcHAuc2V0dGluZ3MubW9kZWxzXFxuICB7cG9zdFBhdGh9ICAgICAgICAgICAgICA9IGFwcC5zZXR0aW5ncy5oZWxwZXJzXFxuICB7bWFya2Rvd24sIG1ha2VUYWdMaXN0fSA9IGFwcC5zZXR0aW5ncy51dGlsc1xcblxcbiAgcmV0dXJuIHtcXG5cXG4gICAgIyBHRVQgL3Bvc3RzXFxuICAgIGluZGV4OiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgIyBjaGVjayBwYWdpbmF0aW9uIHBhcmFtOiAvcG9zdHMvP3BhZ2U9MlxcbiAgICAgIHBhZ2VObyA9IHBhcnNlSW50KHJlcS5xdWVyeVsncGFnZSddLCAxMCkgb3IgMVxcblxcbiAgICAgIFBPU1RTX1BFUl9QQUdFID0gNVxcbiAgICAgIFBvc3QuY291bnRQb3N0UGFnZXMgUE9TVFNfUEVSX1BBR0UsIChlcnIsIHRvdGFsUGFnZXMpIC0+XFxuICAgICAgICBQb3N0LmdldFBvc3RzT2ZQYWdlIHBhZ2VObywgUE9TVFNfUEVSX1BBR0UsIChlcnIsIHBvc3RzKSAtPlxcbiAgICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc1MDAnIGlmIGVycj9cXG4gICAgICAgICAgcmVzLnJlbmRlciAncG9zdHMvaW5kZXgnXFxuICAgICAgICAgICAgcG9zdHM6ICAgICAgcG9zdHNcXG4gICAgICAgICAgICBwYWdlTm86ICAgICBwYWdlTm9cXG4gICAgICAgICAgICB0b3RhbFBhZ2VzOiB0b3RhbFBhZ2VzXFxuXFxuICAgICMgR0VUIC95ZWFyL21vbnRoL2RheS86c2x1Zy46Zm9ybWF0P1xcbiAgICBzaG93OiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgUG9zdC5maW5kQnlTbHVnIHJlcS5wYXJhbXMuc2x1ZywgKGVyciwgcG9zdCkgLT5cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzUwMCcgaWYgZXJyP1xcbiAgICAgICAgcmV0dXJuIHJlcy5yZWRpcmVjdCAnNDA0JyB1bmxlc3MgcG9zdD9cXG4gICAgICAgIHJlcy5yZW5kZXIgJ3Bvc3RzL3Nob3cnXFxuICAgICAgICAgIHBvc3Q6IHBvc3RcXG5cXG4gICAgIyBHRVQgL3Bvc3RzL25ld1xcbiAgICBuZXc6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICByZXMucmVuZGVyICdwb3N0cy9uZXcnXFxuICAgICAgICBwb3N0OiBuZXcgUG9zdFxcblxcbiAgICAjIEdFVCAveWVhci9tb250aC9kYXkvOnNsdWcvZWRpdFxcbiAgICBlZGl0OiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgUG9zdC5maW5kQnlTbHVnIHJlcS5wYXJhbXMuc2x1ZywgKGVyciwgcG9zdCkgLT5cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzUwMCcgaWYgZXJyP1xcbiAgICAgICAgcmV0dXJuIHJlcy5yZWRpcmVjdCAnNDA0JyB1bmxlc3MgcG9zdD9cXG4gICAgICAgIHJlcy5yZW5kZXIgJ3Bvc3RzL2VkaXQnXFxuICAgICAgICAgIHBvc3Q6IHBvc3RcXG5cXG4gICAgIyBQT1NUIC9wb3N0c1xcbiAgICBjcmVhdGU6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICBwb3N0ICAgICAgICAgPSBuZXcgUG9zdFxcbiAgICAgIHBvc3QuZGF0YSAgICA9IHJlcS5ib2R5LnBvc3RcXG4gICAgICBwb3N0LnNhdmUgKGVycikgLT5cXG4gICAgICAgIGlmIGVyclxcbiAgICAgICAgICByZXEuZmxhc2ggJ2Vycm9yJywgZXhjZXB0aW9ucy5nZXRNZXNzYWdlIGVyclxcbiAgICAgICAgICByZXMucmVkaXJlY3QgJ2JhY2snXFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJlcS5mbGFzaCAnaW5mbycsICdzdWNjZXNzZnVsbHkgcG9zdGVkJ1xcbiAgICAgICAgICByZXMucmVkaXJlY3QgcG9zdFBhdGgocG9zdClcXG5cXG4gICAgIyBQVVQgL3llYXIvbW9udGgvZGF5LzpzbHVnXFxuICAgIHVwZGF0ZTogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QuZmluZEJ5U2x1ZyByZXEucGFyYW1zLnNsdWcsIChlcnIsIHBvc3QpIC0+XFxuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc1MDAnIGlmIGVycj9cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzQwNCcgdW5sZXNzIHBvc3Q/XFxuICAgICAgICBwb3N0LmRhdGEgPSByZXEuYm9keS5wb3N0XFxuICAgICAgICBwb3N0LnNhdmUgKGVycikgLT5cXG4gICAgICAgICAgaWYgZXJyXFxuICAgICAgICAgICAgcmVxLmZsYXNoICdlcnJvcicsIGV4Y2VwdGlvbnMuZ2V0TWVzc2FnZSBlcnJcXG4gICAgICAgICAgICByZXMucmVkaXJlY3QgJ2JhY2snXFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXEuZmxhc2ggJ2luZm8nLCAnc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQnXFxuICAgICAgICAgICAgcmVzLnJlZGlyZWN0IHBvc3RQYXRoKHBvc3QpXFxuXFxuICAgICMgREVMRVRFIC95ZWFyL21vbnRoL2RheS86c2x1Z1xcbiAgICBkZXN0cm95OiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgUG9zdC5yZW1vdmVCeVNsdWcgcmVxLnBhcmFtcy5zbHVnLCAoZXJyKSAtPlxcbiAgICAgICAgcmVzLnJlZGlyZWN0ICdiYWNrJ1xcblxcbiAgICAjIGZpbmQgYWxsIHBvc3RzIHB1Ymxpc2hlZCBhcyBpbmRpdmlkdWFsIHBhZ2VzXFxuICAgICMgdGhpcyBpcyBhIG1pZGRsZXdhcmUgdG8gYXBwbHkgYmVmb3JlIGFsbCByZXF1ZXN0c1xcbiAgICBmaW5kUGFnZXM6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICBQb3N0LmZpbmRQYWdlcyAoZXJyLCBwYWdlcykgLT5cXG4gICAgICAgIHJlcy5sb2NhbHMgcGFnZXM6IHBhZ2VzXFxuICAgICAgICBuZXh0KClcXG5cXG4gICAgIyBHRVQgLzpzbHVnXFxuICAgIHNob3dQYWdlOiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgUG9zdC5maW5kQnlTbHVnIHJlcS5wYXJhbXMuc2x1ZywgKGVyciwgcG9zdCkgLT5cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzUwMCcgaWYgZXJyP1xcbiAgICAgICAgcmV0dXJuIG5leHQoKSB1bmxlc3MgcG9zdD9cXG4gICAgICAgIHJlcy5yZW5kZXIgJ3Bvc3RzL3Nob3cnXFxuICAgICAgICAgIHBvc3Q6IHBvc3RcXG5cXG4gICAgIyBHRVQgL2ZlZWRcXG4gICAgZmVlZDogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QuZmluZFBvc3RzIChlcnIsIHBvc3RzKSAtPlxcbiAgICAgICAgZmVlZCA9IG5ldyBSU1NcXG4gICAgICAgICAgdGl0bGU6ICAgICAgIGFwcC5zZXR0aW5ncy5zaXRlbmFtZVxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYXBwLnNldHRpbmdzLmRlc2NyaXB0aW9uXFxuICAgICAgICAgIGZlZWRfdXJsOiAgICBhcHAuc2V0dGluZ3MudXJsICsgJy9mZWVkJ1xcbiAgICAgICAgICBhdXRob3I6ICAgICAgYXBwLnNldHRpbmdzLmF1dGhvclxcblxcbiAgICAgICAgZm9yIHBvc3QgaW4gcG9zdHNcXG4gICAgICAgICAgZmVlZC5pdGVtXFxuICAgICAgICAgICAgdGl0bGU6ICAgICAgIHBvc3QudGl0bGVcXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcG9zdC5jb250ZW50XFxuICAgICAgICAgICAgdXJsOiAgICAgICAgIGFwcC5zZXR0aW5ncy51cmwgKyBwb3N0UGF0aChwb3N0KVxcbiAgICAgICAgICAgIGRhdGU6ICAgICAgICBwb3N0LmNyZWF0ZWRBdFxcblxcbiAgICAgICAgcmVzLnNlbmQgZmVlZC54bWwoKVxcblxcbiAgICAjIFBPU1QgL3Bvc3RzL3ByZXZpZXdcXG4gICAgcHJldmlldzogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIG1hcmtkb3duIHJlcS5ib2R5LnJhd0NvbnRlbnQgb3IgJycsIChodG1sKSAtPlxcbiAgICAgICAgcmVzLnNlbmQgaHRtbCwgMjAwXFxuXFxuICB9XCI7XG5cbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSwgcmVuZGVyO1xuXG4gIGRvbSA9IHJlcXVpcmUoXCIuL2RvbVwiKS5yYWluO1xuICByZW5kZXIgPSByZXF1aXJlKFwiLi9yZW5kZXJcIik7XG4gIGRvbS5vbihcInBhc3RlXCIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbS5lbWl0KFwicmVuZGVyXCIsIHJlbmRlci5jb252ZXJ0KHZhbHVlKSk7XG4gIH0pO1xuICByZXR1cm4gZG9tLmVtaXQoXCJyZW5kZXJcIiwgcmVuZGVyLmNvbnZlcnQodGVzdF9jb2RlKSk7XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxudmFyIGRldGVjdCwgZ2V0X2luZGVudCwgbWFrZV9odG1sLCBtYWtlX2xpc3QsIG1ha2VfdHJlZTtcblxuZGV0ZWN0ID0gcmVxdWlyZShcIi4vZGV0ZWN0XCIpO1xuXG5nZXRfaW5kZW50ID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgbWF0Y2g7XG5cbiAgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eKFxccyopLyk7XG4gIHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG59O1xuXG5tYWtlX2xpc3QgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHJldHVybiBjb2RlLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUudHJpbVJpZ2h0KCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoID4gMDtcbiAgfSk7XG59O1xuXG5tYWtlX3RyZWUgPSBmdW5jdGlvbihsaW5lcykge1xuICB2YXIgbGFzdCwgdHJlZTtcblxuICB0cmVlID0ge307XG4gIGxhc3QgPSB2b2lkIDA7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIHZhciBpbmRlbnQsIG47XG5cbiAgICBuID0gZ2V0X2luZGVudChsaW5lKTtcbiAgICBpbmRlbnQgPSB2b2lkIDA7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyZWVbbGFzdF0pKSB7XG4gICAgICAgIHRyZWVbbGFzdF0gPSBtYWtlX3RyZWUodHJlZVtsYXN0XSk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gbGluZTtcbiAgICAgIHRyZWVbbGFzdF0gPSBbXTtcbiAgICAgIHJldHVybiBpbmRlbnQgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRlbnQgPT0gbnVsbCkge1xuICAgICAgICBpbmRlbnQgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyZWVbbGFzdF0ucHVzaChsaW5lLnNsaWNlKDIpKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlW2xhc3RdKSkge1xuICAgIHRyZWVbbGFzdF0gPSBtYWtlX3RyZWUodHJlZVtsYXN0XSk7XG4gIH1cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG5tYWtlX2h0bWwgPSBmdW5jdGlvbih0cmVlKSB7XG4gIHZhciBhZGQsIGh0bWwsIGtleSwgdmFsdWU7XG5cbiAgaHRtbCA9IFwiXCI7XG4gIGFkZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBodG1sICs9IHN0cmluZztcbiAgfTtcbiAgZm9yIChrZXkgaW4gdHJlZSkge1xuICAgIHZhbHVlID0gdHJlZVtrZXldO1xuICAgIGFkZChcIjxkaXYgY2xhc3M9J3VuaXQnPlwiKTtcbiAgICBhZGQoXCI8ZGl2IGNsYXNzPSdsaW5lJz5cIik7XG4gICAgYWRkKGtleSk7XG4gICAgYWRkKFwiPC9kaXY+XCIpO1xuICAgIGFkZChcIjxkaXYgY2xhc3M9J2Jsb2NrJz5cIik7XG4gICAgYWRkKG1ha2VfaHRtbCh2YWx1ZSkpO1xuICAgIGFkZChcIjwvZGl2PlwiKTtcbiAgICBhZGQoXCI8L2Rpdj5cIik7XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5leHBvcnRzLmNvbnZlcnQgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHJldHVybiBtYWtlX2h0bWwobWFrZV90cmVlKG1ha2VfbGlzdChjb2RlKSkpO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbnZhciB1c2Vfc3BhY2U7XG5cbnVzZV9zcGFjZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUucmVwbGFjZSgvXFx0L2csIFwiICBcIik7XG59O1xuXG5leHBvcnRzLmluZGVudCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgdmFyIGdhdGhlcl9pbmRlbnQsIGluZGVudCwgbGluZXM7XG5cbiAgY29kZSA9IGNvZGUudHJpbSgpO1xuICBpbmRlbnQgPSA4MDtcbiAgZ2F0aGVyX2luZGVudCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgYWZ0ZXIsIGJlZm9yZSwgZGlmZjtcblxuICAgIGJlZm9yZSA9IGxpbmUubGVuZ3RoO1xuICAgIGFmdGVyID0gbGluZS50cmltTGVmdCgpLmxlbmd0aDtcbiAgICBkaWZmID0gYmVmb3JlIC0gYWZ0ZXI7XG4gICAgaWYgKCgwIDwgZGlmZiAmJiBkaWZmIDwgaW5kZW50KSkge1xuICAgICAgcmV0dXJuIGluZGVudCA9IGRpZmY7XG4gICAgfVxuICB9O1xuICBsaW5lcyA9IGNvZGUuc3BsaXQoXCJcXG5cIikubWFwKFN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0LmNhbGwpLm1hcCh1c2Vfc3BhY2UpLm1hcChnYXRoZXJfaW5kZW50KTtcbiAgcmV0dXJuIGluZGVudDtcbn07XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4yXG52YXIgRXZlbnRFbWl0dGVyLCBkZWxheSwgZWxlbSwgZmluZCwgcGFwZXIsIHJhaW47XG5cbmZpbmQgPSBmdW5jdGlvbihxdWVyeSkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuXG5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRlbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcblxuZGVsYXkgPSBmdW5jdGlvbih0LCBmKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGYsIHQpO1xufTtcblxuZXhwb3J0cy5yYWluID0gcmFpbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuZWxlbSA9IGZpbmQoXCIjcGFzdGVcIik7XG5cbnBhcGVyID0gZmluZChcIiNwYXBlclwiKTtcblxucGFwZXIub25jbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBuZXh0LCBzdHlsZTtcblxuICBlbGVtID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoZWxlbS5jbGFzc05hbWUgPSBcImxpbmVcIikge1xuICAgIG5leHQgPSBlbGVtLm5leHRFbGVtZW50U2libGluZztcbiAgICBzdHlsZSA9IG5leHQuc3R5bGU7XG4gICAgaWYgKHN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSBcImhzbGEoMjQwLDgwJSw5MCUsMClcIjtcbiAgICAgIHJldHVybiBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH0gZWxzZSBpZiAobmV4dC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9IFwiaHNsKDI0MCw4MCUsOTAlKVwiO1xuICAgICAgcmV0dXJuIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn07XG5cbmVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZGVsYXkoMCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJhaW4uZW1pdChcInBhc3RlXCIsIGVsZW0udmFsdWUpO1xuICB9KTtcbn0pO1xuXG5yYWluLm9uKFwicmVuZGVyXCIsIGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIHBhcGVyLmlubmVySFRNTCA9IGh0bWw7XG59KTtcbiIsIihmdW5jdGlvbigpeyhmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBwcm9jZXNzID0geyBFdmVudEVtaXR0ZXI6IGZ1bmN0aW9uKCkge30gfTtcbiAgXG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gXCJmdW5jdGlvblwiKXtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24ob2JqKXsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCIgfTtcbiAgfVxuICBcbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZil7XG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzWyBpIF0gPT09IGl0ZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuICBcbiAgLy8gQmVnaW4gd3JhcCBvZiBub2RlanMgaW1wbGVtZW50YXRpb24gb2YgRXZlbnRFbWl0dGVyXG5cbiAgdmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICAgIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBzbG93ZXJcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2NcbiAgLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICAgIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfTtcblxuICAvLyBFbmQgbm9kZWpzIGltcGxlbWVudGF0aW9uXG59KCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogZXhwb3J0cykpO1xufSkoKSJdfQ==
;