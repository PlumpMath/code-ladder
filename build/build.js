;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var test_code;

test_code = "# https://github.com/qiao/coffee-box/blob/master/app/controllers/posts_controller.coffee\nexports.getPostsController = (app) ->\n  exceptions              = require '../../lib/exceptions'\n  RSS                     = require('rss')\n  {Post}                  = app.settings.models\n  {postPath}              = app.settings.helpers\n  {markdown, makeTagList} = app.settings.utils\n\n  return {\n\n    # GET /posts\n    index: (req, res, next) ->\n      # check pagination param: /posts/?page=2\n      pageNo = parseInt(req.query['page'], 10) or 1\n\n      POSTS_PER_PAGE = 5\n      Post.countPostPages POSTS_PER_PAGE, (err, totalPages) ->\n        Post.getPostsOfPage pageNo, POSTS_PER_PAGE, (err, posts) ->\n          return res.redirect '500' if err?\n          res.render 'posts/index'\n            posts:      posts\n            pageNo:     pageNo\n            totalPages: totalPages\n\n    # GET /year/month/day/:slug.:format?\n    show: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        res.render 'posts/show'\n          post: post\n\n    # GET /posts/new\n    new: (req, res, next) ->\n      res.render 'posts/new'\n        post: new Post\n\n    # GET /year/month/day/:slug/edit\n    edit: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        res.render 'posts/edit'\n          post: post\n\n    # POST /posts\n    create: (req, res, next) ->\n      post         = new Post\n      post.data    = req.body.post\n      post.save (err) ->\n        if err\n          req.flash 'error', exceptions.getMessage err\n          res.redirect 'back'\n        else\n          req.flash 'info', 'successfully posted'\n          res.redirect postPath(post)\n\n    # PUT /year/month/day/:slug\n    update: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return res.redirect '404' unless post?\n        post.data = req.body.post\n        post.save (err) ->\n          if err\n            req.flash 'error', exceptions.getMessage err\n            res.redirect 'back'\n          else\n            req.flash 'info', 'successfully updated'\n            res.redirect postPath(post)\n\n    # DELETE /year/month/day/:slug\n    destroy: (req, res, next) ->\n      Post.removeBySlug req.params.slug, (err) ->\n        res.redirect 'back'\n\n    # find all posts published as individual pages\n    # this is a middleware to apply before all requests\n    findPages: (req, res, next) ->\n      Post.findPages (err, pages) ->\n        res.locals pages: pages\n        next()\n\n    # GET /:slug\n    showPage: (req, res, next) ->\n      Post.findBySlug req.params.slug, (err, post) ->\n        return res.redirect '500' if err?\n        return next() unless post?\n        res.render 'posts/show'\n          post: post\n\n    # GET /feed\n    feed: (req, res, next) ->\n      Post.findPosts (err, posts) ->\n        feed = new RSS\n          title:       app.settings.sitename\n          description: app.settings.description\n          feed_url:    app.settings.url + '/feed'\n          author:      app.settings.author\n\n        for post in posts\n          feed.item\n            title:       post.title\n            description: post.content\n            url:         app.settings.url + postPath(post)\n            date:        post.createdAt\n\n        res.send feed.xml()\n\n    # POST /posts/preview\n    preview: (req, res, next) ->\n      markdown req.body.rawContent or '', (html) ->\n        res.send html, 200\n\n  }";

window.onload = function() {
  var dom, render;

  dom = require("./dom").rain;
  render = require("./render");
  dom.on("paste", function(value) {
    return dom.emit("render", render.convert(value));
  });
  return dom.emit("render", render.convert(test_code));
};

},{"./dom":2,"./render":3}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var detect, escapeHTML, get_indent, make_html, make_list, make_tree;

detect = require("./detect");

get_indent = function(line) {
  var match;

  match = line.match(/^(\s*)/);
  return match[0].length;
};

escapeHTML = function(string) {
  return string.replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

make_list = function(code) {
  return code.split("\n").map(function(line) {
    return line.trimRight();
  }).filter(function(line) {
    return line.length > 0;
  }).map(escapeHTML);
};

make_tree = function(lines) {
  var last, tree;

  tree = {};
  last = void 0;
  lines.forEach(function(line) {
    var indent, n;

    n = get_indent(line);
    indent = void 0;
    if (n === 0) {
      if (Array.isArray(tree[last])) {
        tree[last] = make_tree(tree[last]);
      }
      last = line;
      tree[last] = [];
      return indent = void 0;
    } else {
      if (indent == null) {
        indent = n;
      }
      return tree[last].push(line.slice(2));
    }
  });
  if (Array.isArray(tree[last])) {
    tree[last] = make_tree(tree[last]);
  }
  return tree;
};

make_html = function(tree) {
  var add, html, key, value;

  html = "";
  add = function(string) {
    return html += string;
  };
  for (key in tree) {
    value = tree[key];
    add("<div class='unit'>");
    add("<div class='line'>");
    add(key);
    add("</div>");
    add("<div class='block'>");
    add(make_html(value));
    add("</div>");
    add("</div>");
  }
  return html;
};

exports.convert = function(code) {
  return make_html(make_tree(make_list(code)));
};

},{"./detect":4}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var use_space;

use_space = function(line) {
  return line.replace(/\t/g, "  ");
};

exports.indent = function(code) {
  var gather_indent, indent, lines;

  code = code.trim();
  indent = 80;
  gather_indent = function(line) {
    var after, before, diff;

    before = line.length;
    after = line.trimLeft().length;
    diff = before - after;
    if ((0 < diff && diff < indent)) {
      return indent = diff;
    }
  };
  lines = code.split("\n").map(String.prototype.trimRight.call).map(use_space).map(gather_indent);
  return indent;
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var EventEmitter, all, delay, paper, paste, q, rain;

q = function(query) {
  return document.querySelector(query);
};

all = function(query) {
  return document.querySelectorAll(query);
};

EventEmitter = require("eventemitter").EventEmitter;

delay = function(t, f) {
  return setTimeout(f, t);
};

exports.rain = rain = new EventEmitter();

paste = q("#paste");

paper = q("#paper");

paper.onclick = function(event) {
  var elem, next, style;

  elem = event.target;
  if (elem.className === "line") {
    next = elem.nextElementSibling;
    style = next.style;
    if (style.opacity === "0") {
      elem.style.background = "hsla(240,80%,90%,0)";
      return style.opacity = "1";
    } else if (next.childElementCount > 0) {
      elem.style.background = "hsl(240,80%,93%)";
      return style.opacity = "0";
    }
  }
};

q("#fold").onclick = function() {
  return Array.prototype.map.call(all(".block"), function(elem) {
    elem.style.opacity = "1";
    return elem.previousElementSibling.click();
  });
};

q("#expand").onclick = function() {
  return Array.prototype.map.call(all(".block"), function(elem) {
    elem.style.opacity = "0";
    return elem.previousElementSibling.click();
  });
};

paste.addEventListener("paste", function() {
  return delay(0, function() {
    return rain.emit("paste", paste.value);
  });
});

rain.on("render", function(html) {
  paper.innerHTML = html;
  return Array.prototype.map.call(all(".block"), function(elem) {
    return elem.style.opacity = "1";
  });
});

},{"eventemitter":5}],5:[function(require,module,exports){
(function(){(function(exports) {
  var process = { EventEmitter: function() {} };
  
  if (typeof Array.isArray !== "function"){
    Array.isArray = function(obj){ return Object.prototype.toString.call(obj) === "[object Array]" };
  }
  
  if (!Array.prototype.indexOf){
    Array.prototype.indexOf = function(item){
        for ( var i = 0, length = this.length; i < length; i++ ) {
            if ( this[ i ] === item ) {
                return i;
            }
        }

        return -1;
    };
  }
  
  // Begin wrap of nodejs implementation of EventEmitter

  var EventEmitter = exports.EventEmitter = process.EventEmitter;

  var isArray = Array.isArray;

  EventEmitter.prototype.emit = function(type) {
    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events || !this._events.error ||
          (isArray(this._events.error) && !this._events.error.length))
      {
        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    if (!this._events) return false;
    var handler = this._events[type];
    if (!handler) return false;

    if (typeof handler == 'function') {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          var args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
      }
      return true;

    } else if (isArray(handler)) {
      var args = Array.prototype.slice.call(arguments, 1);

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
      return true;

    } else {
      return false;
    }
  };

  // EventEmitter is defined in src/node_events.cc
  // EventEmitter.prototype.emit() is also defined there.
  EventEmitter.prototype.addListener = function(type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('addListener only takes instances of Function');
    }

    if (!this._events) this._events = {};

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);
    } else {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function(type, listener) {
    var self = this;
    self.on(type, function g() {
      self.removeListener(type, g);
      listener.apply(this, arguments);
    });
  };

  EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('removeListener only takes instances of Function');
    }

    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
      var i = list.indexOf(listener);
      if (i < 0) return this;
      list.splice(i, 1);
      if (list.length == 0)
        delete this._events[type];
    } else if (this._events[type] === listener) {
      delete this._events[type];
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function(type) {
    // does not use listeners(), so no side effect of creating _events[type]
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  // End nodejs implementation
}((typeof exports === 'undefined') ? window : exports));
})()
},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvb3B0L3MvY29kZS1sYWRkZXIvbGliL21haW4uanMiLCIvb3B0L3MvY29kZS1sYWRkZXIvbGliL3JlbmRlci5qcyIsIi9vcHQvcy9jb2RlLWxhZGRlci9saWIvZGV0ZWN0LmpzIiwiL29wdC9zL2NvZGUtbGFkZGVyL2xpYi9kb20uanMiLCIvb3B0L3MvY29kZS1sYWRkZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxudmFyIHRlc3RfY29kZTtcblxudGVzdF9jb2RlID0gXCIjIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL2NvZmZlZS1ib3gvYmxvYi9tYXN0ZXIvYXBwL2NvbnRyb2xsZXJzL3Bvc3RzX2NvbnRyb2xsZXIuY29mZmVlXFxuZXhwb3J0cy5nZXRQb3N0c0NvbnRyb2xsZXIgPSAoYXBwKSAtPlxcbiAgZXhjZXB0aW9ucyAgICAgICAgICAgICAgPSByZXF1aXJlICcuLi8uLi9saWIvZXhjZXB0aW9ucydcXG4gIFJTUyAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgncnNzJylcXG4gIHtQb3N0fSAgICAgICAgICAgICAgICAgID0gYXBwLnNldHRpbmdzLm1vZGVsc1xcbiAge3Bvc3RQYXRofSAgICAgICAgICAgICAgPSBhcHAuc2V0dGluZ3MuaGVscGVyc1xcbiAge21hcmtkb3duLCBtYWtlVGFnTGlzdH0gPSBhcHAuc2V0dGluZ3MudXRpbHNcXG5cXG4gIHJldHVybiB7XFxuXFxuICAgICMgR0VUIC9wb3N0c1xcbiAgICBpbmRleDogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgICMgY2hlY2sgcGFnaW5hdGlvbiBwYXJhbTogL3Bvc3RzLz9wYWdlPTJcXG4gICAgICBwYWdlTm8gPSBwYXJzZUludChyZXEucXVlcnlbJ3BhZ2UnXSwgMTApIG9yIDFcXG5cXG4gICAgICBQT1NUU19QRVJfUEFHRSA9IDVcXG4gICAgICBQb3N0LmNvdW50UG9zdFBhZ2VzIFBPU1RTX1BFUl9QQUdFLCAoZXJyLCB0b3RhbFBhZ2VzKSAtPlxcbiAgICAgICAgUG9zdC5nZXRQb3N0c09mUGFnZSBwYWdlTm8sIFBPU1RTX1BFUl9QQUdFLCAoZXJyLCBwb3N0cykgLT5cXG4gICAgICAgICAgcmV0dXJuIHJlcy5yZWRpcmVjdCAnNTAwJyBpZiBlcnI/XFxuICAgICAgICAgIHJlcy5yZW5kZXIgJ3Bvc3RzL2luZGV4J1xcbiAgICAgICAgICAgIHBvc3RzOiAgICAgIHBvc3RzXFxuICAgICAgICAgICAgcGFnZU5vOiAgICAgcGFnZU5vXFxuICAgICAgICAgICAgdG90YWxQYWdlczogdG90YWxQYWdlc1xcblxcbiAgICAjIEdFVCAveWVhci9tb250aC9kYXkvOnNsdWcuOmZvcm1hdD9cXG4gICAgc2hvdzogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QuZmluZEJ5U2x1ZyByZXEucGFyYW1zLnNsdWcsIChlcnIsIHBvc3QpIC0+XFxuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc1MDAnIGlmIGVycj9cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzQwNCcgdW5sZXNzIHBvc3Q/XFxuICAgICAgICByZXMucmVuZGVyICdwb3N0cy9zaG93J1xcbiAgICAgICAgICBwb3N0OiBwb3N0XFxuXFxuICAgICMgR0VUIC9wb3N0cy9uZXdcXG4gICAgbmV3OiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgcmVzLnJlbmRlciAncG9zdHMvbmV3J1xcbiAgICAgICAgcG9zdDogbmV3IFBvc3RcXG5cXG4gICAgIyBHRVQgL3llYXIvbW9udGgvZGF5LzpzbHVnL2VkaXRcXG4gICAgZWRpdDogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QuZmluZEJ5U2x1ZyByZXEucGFyYW1zLnNsdWcsIChlcnIsIHBvc3QpIC0+XFxuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc1MDAnIGlmIGVycj9cXG4gICAgICAgIHJldHVybiByZXMucmVkaXJlY3QgJzQwNCcgdW5sZXNzIHBvc3Q/XFxuICAgICAgICByZXMucmVuZGVyICdwb3N0cy9lZGl0J1xcbiAgICAgICAgICBwb3N0OiBwb3N0XFxuXFxuICAgICMgUE9TVCAvcG9zdHNcXG4gICAgY3JlYXRlOiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgcG9zdCAgICAgICAgID0gbmV3IFBvc3RcXG4gICAgICBwb3N0LmRhdGEgICAgPSByZXEuYm9keS5wb3N0XFxuICAgICAgcG9zdC5zYXZlIChlcnIpIC0+XFxuICAgICAgICBpZiBlcnJcXG4gICAgICAgICAgcmVxLmZsYXNoICdlcnJvcicsIGV4Y2VwdGlvbnMuZ2V0TWVzc2FnZSBlcnJcXG4gICAgICAgICAgcmVzLnJlZGlyZWN0ICdiYWNrJ1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICByZXEuZmxhc2ggJ2luZm8nLCAnc3VjY2Vzc2Z1bGx5IHBvc3RlZCdcXG4gICAgICAgICAgcmVzLnJlZGlyZWN0IHBvc3RQYXRoKHBvc3QpXFxuXFxuICAgICMgUFVUIC95ZWFyL21vbnRoL2RheS86c2x1Z1xcbiAgICB1cGRhdGU6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICBQb3N0LmZpbmRCeVNsdWcgcmVxLnBhcmFtcy5zbHVnLCAoZXJyLCBwb3N0KSAtPlxcbiAgICAgICAgcmV0dXJuIHJlcy5yZWRpcmVjdCAnNTAwJyBpZiBlcnI/XFxuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc0MDQnIHVubGVzcyBwb3N0P1xcbiAgICAgICAgcG9zdC5kYXRhID0gcmVxLmJvZHkucG9zdFxcbiAgICAgICAgcG9zdC5zYXZlIChlcnIpIC0+XFxuICAgICAgICAgIGlmIGVyclxcbiAgICAgICAgICAgIHJlcS5mbGFzaCAnZXJyb3InLCBleGNlcHRpb25zLmdldE1lc3NhZ2UgZXJyXFxuICAgICAgICAgICAgcmVzLnJlZGlyZWN0ICdiYWNrJ1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgcmVxLmZsYXNoICdpbmZvJywgJ3N1Y2Nlc3NmdWxseSB1cGRhdGVkJ1xcbiAgICAgICAgICAgIHJlcy5yZWRpcmVjdCBwb3N0UGF0aChwb3N0KVxcblxcbiAgICAjIERFTEVURSAveWVhci9tb250aC9kYXkvOnNsdWdcXG4gICAgZGVzdHJveTogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QucmVtb3ZlQnlTbHVnIHJlcS5wYXJhbXMuc2x1ZywgKGVycikgLT5cXG4gICAgICAgIHJlcy5yZWRpcmVjdCAnYmFjaydcXG5cXG4gICAgIyBmaW5kIGFsbCBwb3N0cyBwdWJsaXNoZWQgYXMgaW5kaXZpZHVhbCBwYWdlc1xcbiAgICAjIHRoaXMgaXMgYSBtaWRkbGV3YXJlIHRvIGFwcGx5IGJlZm9yZSBhbGwgcmVxdWVzdHNcXG4gICAgZmluZFBhZ2VzOiAocmVxLCByZXMsIG5leHQpIC0+XFxuICAgICAgUG9zdC5maW5kUGFnZXMgKGVyciwgcGFnZXMpIC0+XFxuICAgICAgICByZXMubG9jYWxzIHBhZ2VzOiBwYWdlc1xcbiAgICAgICAgbmV4dCgpXFxuXFxuICAgICMgR0VUIC86c2x1Z1xcbiAgICBzaG93UGFnZTogKHJlcSwgcmVzLCBuZXh0KSAtPlxcbiAgICAgIFBvc3QuZmluZEJ5U2x1ZyByZXEucGFyYW1zLnNsdWcsIChlcnIsIHBvc3QpIC0+XFxuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0ICc1MDAnIGlmIGVycj9cXG4gICAgICAgIHJldHVybiBuZXh0KCkgdW5sZXNzIHBvc3Q/XFxuICAgICAgICByZXMucmVuZGVyICdwb3N0cy9zaG93J1xcbiAgICAgICAgICBwb3N0OiBwb3N0XFxuXFxuICAgICMgR0VUIC9mZWVkXFxuICAgIGZlZWQ6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICBQb3N0LmZpbmRQb3N0cyAoZXJyLCBwb3N0cykgLT5cXG4gICAgICAgIGZlZWQgPSBuZXcgUlNTXFxuICAgICAgICAgIHRpdGxlOiAgICAgICBhcHAuc2V0dGluZ3Muc2l0ZW5hbWVcXG4gICAgICAgICAgZGVzY3JpcHRpb246IGFwcC5zZXR0aW5ncy5kZXNjcmlwdGlvblxcbiAgICAgICAgICBmZWVkX3VybDogICAgYXBwLnNldHRpbmdzLnVybCArICcvZmVlZCdcXG4gICAgICAgICAgYXV0aG9yOiAgICAgIGFwcC5zZXR0aW5ncy5hdXRob3JcXG5cXG4gICAgICAgIGZvciBwb3N0IGluIHBvc3RzXFxuICAgICAgICAgIGZlZWQuaXRlbVxcbiAgICAgICAgICAgIHRpdGxlOiAgICAgICBwb3N0LnRpdGxlXFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHBvc3QuY29udGVudFxcbiAgICAgICAgICAgIHVybDogICAgICAgICBhcHAuc2V0dGluZ3MudXJsICsgcG9zdFBhdGgocG9zdClcXG4gICAgICAgICAgICBkYXRlOiAgICAgICAgcG9zdC5jcmVhdGVkQXRcXG5cXG4gICAgICAgIHJlcy5zZW5kIGZlZWQueG1sKClcXG5cXG4gICAgIyBQT1NUIC9wb3N0cy9wcmV2aWV3XFxuICAgIHByZXZpZXc6IChyZXEsIHJlcywgbmV4dCkgLT5cXG4gICAgICBtYXJrZG93biByZXEuYm9keS5yYXdDb250ZW50IG9yICcnLCAoaHRtbCkgLT5cXG4gICAgICAgIHJlcy5zZW5kIGh0bWwsIDIwMFxcblxcbiAgfVwiO1xuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20sIHJlbmRlcjtcblxuICBkb20gPSByZXF1aXJlKFwiLi9kb21cIikucmFpbjtcbiAgcmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyXCIpO1xuICBkb20ub24oXCJwYXN0ZVwiLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBkb20uZW1pdChcInJlbmRlclwiLCByZW5kZXIuY29udmVydCh2YWx1ZSkpO1xuICB9KTtcbiAgcmV0dXJuIGRvbS5lbWl0KFwicmVuZGVyXCIsIHJlbmRlci5jb252ZXJ0KHRlc3RfY29kZSkpO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbnZhciBkZXRlY3QsIGVzY2FwZUhUTUwsIGdldF9pbmRlbnQsIG1ha2VfaHRtbCwgbWFrZV9saXN0LCBtYWtlX3RyZWU7XG5cbmRldGVjdCA9IHJlcXVpcmUoXCIuL2RldGVjdFwiKTtcblxuZ2V0X2luZGVudCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIG1hdGNoO1xuXG4gIG1hdGNoID0gbGluZS5tYXRjaCgvXihcXHMqKS8pO1xuICByZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xufTtcblxuZXNjYXBlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xufTtcblxubWFrZV9saXN0ID0gZnVuY3Rpb24oY29kZSkge1xuICByZXR1cm4gY29kZS5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW1SaWdodCgpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLmxlbmd0aCA+IDA7XG4gIH0pLm1hcChlc2NhcGVIVE1MKTtcbn07XG5cbm1ha2VfdHJlZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gIHZhciBsYXN0LCB0cmVlO1xuXG4gIHRyZWUgPSB7fTtcbiAgbGFzdCA9IHZvaWQgMDtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIGluZGVudCwgbjtcblxuICAgIG4gPSBnZXRfaW5kZW50KGxpbmUpO1xuICAgIGluZGVudCA9IHZvaWQgMDtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZVtsYXN0XSkpIHtcbiAgICAgICAgdHJlZVtsYXN0XSA9IG1ha2VfdHJlZSh0cmVlW2xhc3RdKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBsaW5lO1xuICAgICAgdHJlZVtsYXN0XSA9IFtdO1xuICAgICAgcmV0dXJuIGluZGVudCA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluZGVudCA9PSBudWxsKSB7XG4gICAgICAgIGluZGVudCA9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJlZVtsYXN0XS5wdXNoKGxpbmUuc2xpY2UoMikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWVbbGFzdF0pKSB7XG4gICAgdHJlZVtsYXN0XSA9IG1ha2VfdHJlZSh0cmVlW2xhc3RdKTtcbiAgfVxuICByZXR1cm4gdHJlZTtcbn07XG5cbm1ha2VfaHRtbCA9IGZ1bmN0aW9uKHRyZWUpIHtcbiAgdmFyIGFkZCwgaHRtbCwga2V5LCB2YWx1ZTtcblxuICBodG1sID0gXCJcIjtcbiAgYWRkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGh0bWwgKz0gc3RyaW5nO1xuICB9O1xuICBmb3IgKGtleSBpbiB0cmVlKSB7XG4gICAgdmFsdWUgPSB0cmVlW2tleV07XG4gICAgYWRkKFwiPGRpdiBjbGFzcz0ndW5pdCc+XCIpO1xuICAgIGFkZChcIjxkaXYgY2xhc3M9J2xpbmUnPlwiKTtcbiAgICBhZGQoa2V5KTtcbiAgICBhZGQoXCI8L2Rpdj5cIik7XG4gICAgYWRkKFwiPGRpdiBjbGFzcz0nYmxvY2snPlwiKTtcbiAgICBhZGQobWFrZV9odG1sKHZhbHVlKSk7XG4gICAgYWRkKFwiPC9kaXY+XCIpO1xuICAgIGFkZChcIjwvZGl2PlwiKTtcbiAgfVxuICByZXR1cm4gaHRtbDtcbn07XG5cbmV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgcmV0dXJuIG1ha2VfaHRtbChtYWtlX3RyZWUobWFrZV9saXN0KGNvZGUpKSk7XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxudmFyIHVzZV9zcGFjZTtcblxudXNlX3NwYWNlID0gZnVuY3Rpb24obGluZSkge1xuICByZXR1cm4gbGluZS5yZXBsYWNlKC9cXHQvZywgXCIgIFwiKTtcbn07XG5cbmV4cG9ydHMuaW5kZW50ID0gZnVuY3Rpb24oY29kZSkge1xuICB2YXIgZ2F0aGVyX2luZGVudCwgaW5kZW50LCBsaW5lcztcblxuICBjb2RlID0gY29kZS50cmltKCk7XG4gIGluZGVudCA9IDgwO1xuICBnYXRoZXJfaW5kZW50ID0gZnVuY3Rpb24obGluZSkge1xuICAgIHZhciBhZnRlciwgYmVmb3JlLCBkaWZmO1xuXG4gICAgYmVmb3JlID0gbGluZS5sZW5ndGg7XG4gICAgYWZ0ZXIgPSBsaW5lLnRyaW1MZWZ0KCkubGVuZ3RoO1xuICAgIGRpZmYgPSBiZWZvcmUgLSBhZnRlcjtcbiAgICBpZiAoKDAgPCBkaWZmICYmIGRpZmYgPCBpbmRlbnQpKSB7XG4gICAgICByZXR1cm4gaW5kZW50ID0gZGlmZjtcbiAgICB9XG4gIH07XG4gIGxpbmVzID0gY29kZS5zcGxpdChcIlxcblwiKS5tYXAoU3RyaW5nLnByb3RvdHlwZS50cmltUmlnaHQuY2FsbCkubWFwKHVzZV9zcGFjZSkubWFwKGdhdGhlcl9pbmRlbnQpO1xuICByZXR1cm4gaW5kZW50O1xufTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbnZhciBFdmVudEVtaXR0ZXIsIGFsbCwgZGVsYXksIHBhcGVyLCBwYXN0ZSwgcSwgcmFpbjtcblxucSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5cbmFsbCA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbn07XG5cbkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xuXG5kZWxheSA9IGZ1bmN0aW9uKHQsIGYpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZiwgdCk7XG59O1xuXG5leHBvcnRzLnJhaW4gPSByYWluID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5wYXN0ZSA9IHEoXCIjcGFzdGVcIik7XG5cbnBhcGVyID0gcShcIiNwYXBlclwiKTtcblxucGFwZXIub25jbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBlbGVtLCBuZXh0LCBzdHlsZTtcblxuICBlbGVtID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IFwibGluZVwiKSB7XG4gICAgbmV4dCA9IGVsZW0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIHN0eWxlID0gbmV4dC5zdHlsZTtcbiAgICBpZiAoc3R5bGUub3BhY2l0eSA9PT0gXCIwXCIpIHtcbiAgICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9IFwiaHNsYSgyNDAsODAlLDkwJSwwKVwiO1xuICAgICAgcmV0dXJuIHN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICB9IGVsc2UgaWYgKG5leHQuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSBcImhzbCgyNDAsODAlLDkzJSlcIjtcbiAgICAgIHJldHVybiBzdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgfVxuICB9XG59O1xuXG5xKFwiI2ZvbGRcIikub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFsbChcIi5ibG9ja1wiKSwgZnVuY3Rpb24oZWxlbSkge1xuICAgIGVsZW0uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgIHJldHVybiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xpY2soKTtcbiAgfSk7XG59O1xuXG5xKFwiI2V4cGFuZFwiKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYWxsKFwiLmJsb2NrXCIpLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgZWxlbS5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgcmV0dXJuIGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZy5jbGljaygpO1xuICB9KTtcbn07XG5cbnBhc3RlLmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRlbGF5KDAsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByYWluLmVtaXQoXCJwYXN0ZVwiLCBwYXN0ZS52YWx1ZSk7XG4gIH0pO1xufSk7XG5cbnJhaW4ub24oXCJyZW5kZXJcIiwgZnVuY3Rpb24oaHRtbCkge1xuICBwYXBlci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFsbChcIi5ibG9ja1wiKSwgZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgfSk7XG59KTtcbiIsIihmdW5jdGlvbigpeyhmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBwcm9jZXNzID0geyBFdmVudEVtaXR0ZXI6IGZ1bmN0aW9uKCkge30gfTtcbiAgXG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gXCJmdW5jdGlvblwiKXtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24ob2JqKXsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCIgfTtcbiAgfVxuICBcbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZil7XG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzWyBpIF0gPT09IGl0ZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuICBcbiAgLy8gQmVnaW4gd3JhcCBvZiBub2RlanMgaW1wbGVtZW50YXRpb24gb2YgRXZlbnRFbWl0dGVyXG5cbiAgdmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICAgIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBzbG93ZXJcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2NcbiAgLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICAgIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfTtcblxuICAvLyBFbmQgbm9kZWpzIGltcGxlbWVudGF0aW9uXG59KCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogZXhwb3J0cykpO1xufSkoKSJdfQ==
;